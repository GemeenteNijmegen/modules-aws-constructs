import { Duration, RemovalPolicy } from 'aws-cdk-lib';
import { Alarm, TreatMissingData } from 'aws-cdk-lib/aws-cloudwatch';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import { FilterPattern, IFilterPattern, ILogGroup, MetricFilter } from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';
import { Criticality, CriticalityLevel } from './Criticality/Criticality';


/**
 * Construct that easily adds basic error monitoring with an alarm to lambda's
 * Only a lambda needed as property, all others are optional.
 *
 * The plan is to add other basic alarms in the future and add the criticality type when it is added to a library
 */

export interface ErrorRateProps {
  /**
   * The filterpattern used
   * @default FilterPattern.anyTerm('ERROR')
   */
  readonly filterPattern?: IFilterPattern;
  /**
   * Alarm Threshold
   * @default 5
   */
  readonly alarmThreshold?: number;
  /**
   * Evaluation periods (how many periods should be evaluated before an alarm is raised)
   * @default 3
   */
  readonly alarmEvaluationPeriods?: number;
  /**
   * Evaluation period size
   * @default 5 min
   */
  readonly alarmEvaluationPeriod?: Duration;
}
export interface ErrorMonitoringAlarmProps {
  /**
   * The lambda the metrics are added to
   */
  readonly lambda?: lambda.Function;

  /**
   * The log group the metrics are added to
   */
  readonly logGroup?: ILogGroup;

  /**
 * Criticality level
 * @example 'low' | 'medium' | 'high' | 'critical'
 * @default 'low'
 */
  readonly criticality?: CriticalityLevel | Criticality;

  /**
 * Left empty, the id will be used to set the metricNameSpace base
 * @default id
 */
  readonly metricNameSpace?: string;
  /**
   *  All the optional properties for the errorRateMetric and Alarm
   */
  readonly errorRateProps?: ErrorRateProps | undefined;
}
export class ErrorMonitoringAlarm extends Construct {

  constructor(scope: Construct, id: string, props: ErrorMonitoringAlarmProps ) {
    super(scope, id);
    if ((!props.logGroup && !props.lambda) || (props.logGroup && props.lambda)) {
      throw Error('Provide either a lambda or a log group!');
    }
    this.addErrorRateMetric(id, props);

  }

  /**
   * Monitor the logs generated by this function for a filter pattern, generate metric
   * and alarm on increased error rate.
   *
   * @param filterPattern Pattern to filter by (default: containing ERROR)
   */
  private addErrorRateMetric(id: string, props: ErrorMonitoringAlarmProps) {
    const metricNameBase = props.metricNameSpace ?? id;
    const errorMetricFilter = new MetricFilter(this, 'MetricFilter', {
      logGroup: props.lambda?.logGroup! ?? props.logGroup,
      metricNamespace: `${metricNameBase}/${this.node.id}`,
      metricName: 'Errors',
      filterPattern: props.errorRateProps?.filterPattern ?? FilterPattern.anyTerm('ERROR'),
      metricValue: '1',
    });
    errorMetricFilter.applyRemovalPolicy(RemovalPolicy.DESTROY);

    let criticality = new Criticality('low');
    if (props.criticality && props.criticality instanceof Criticality) {
      criticality = props.criticality;
    } else if (props.criticality) {
      criticality = Criticality.fromString(props.criticality);
    }
    const alarm = new Alarm(this, `${metricNameBase}-${this.node.id}-alarm`, {
      metric: errorMetricFilter.metric({
        statistic: 'sum',
        period: props.errorRateProps?.alarmEvaluationPeriod ?? Duration.minutes(5),
      }),
      evaluationPeriods: props.errorRateProps?.alarmEvaluationPeriods ?? 3,
      threshold: props.errorRateProps?.alarmThreshold ?? 5,
      alarmName: `increased-error-rate-${this.node.id}${criticality.alarmSuffix()}`,
      alarmDescription: `This alarm triggers if the function ${metricNameBase} - ${this.node.id} is logging more than 5 errors over n minutes.`,
      treatMissingData: TreatMissingData.NOT_BREACHING,
    });
    alarm.applyRemovalPolicy(RemovalPolicy.DESTROY);
  }
}


